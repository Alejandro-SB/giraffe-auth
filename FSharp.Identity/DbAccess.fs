namespace FSharp.Identity.Stores

open System
open System.Data
open Microsoft.AspNetCore.Identity
open System.Threading.Tasks
open Npgsql.FSharp
open Microsoft.FSharp.Reflection

module DbAccess =
    // generate a function of type RowReader -> 't that looks for fields to map based on lowercase field names
    let autoGeneratedRecordReader<'t> =
        let t = typeof<'t>
        let (constructor, properties) = 
            match FSharpType.IsRecord typeof<'t> with
            | true -> (FSharpValue.PreComputeRecordConstructor t, FSharpType.GetRecordFields t)
            | false -> (fun _ -> t.GetConstructor(Array.empty)), t.GetProperties()
        
        //let createRecord = FSharpValue.PreComputeRecordConstructor typeof<'t>
        let make values = constructor values :?> 't
        let fields = properties |> Array.map (fun p -> p.Name, p.PropertyType)
        //let fields = FSharpType.GetRecordFields typeof<'t> |> Array.map (fun p -> p.Name, p.PropertyType)

        let readField (r: RowReader) (n: string) (t: System.Type) =
            if   t = typeof<int> then r.int n |> box
            elif t = typeof<int option> then r.intOrNone n |> box
            elif t = typeof<int16> then r.int16 n |> box
            elif t = typeof<int16 option> then r.int16OrNone n |> box
            elif t = typeof<int []> then r.intArray n |> box
            elif t = typeof<int [] option> then r.intArrayOrNone n |> box
            elif t = typeof<string []> then r.stringArray n |> box
            elif t = typeof<string [] option> then r.stringArrayOrNone n |> box
            elif t = typeof<int64> then r.int64 n |> box
            elif t = typeof<int64 option> then r.int64OrNone n |> box
            elif t = typeof<string> then r.string n |> box
            elif t = typeof<string option> then r.stringOrNone n |> box
            elif t = typeof<bool> then r.bool n |> box
            elif t = typeof<bool option> then r.boolOrNone n |> box
            elif t = typeof<decimal> then r.decimal n |> box
            elif t = typeof<decimal option> then r.decimalOrNone n |> box
            elif t = typeof<double> then r.double n |> box
            elif t = typeof<double option> then r.doubleOrNone n |> box
            elif t = typeof<DateTime> then r.dateTime n |> box
            elif t = typeof<DateTime option> then r.dateTimeOrNone n |> box
            elif t = typeof<Guid> then r.uuid n |> box
            elif t = typeof<Guid option> then r.uuidOrNone n |> box
            elif t = typeof<byte[]> then r.bytea n |> box
            elif t = typeof<byte[] option> then r.byteaOrNone n |> box
            elif t = typeof<float> then r.float n |> box
            elif t = typeof<float option> then r.floatOrNone n |> box
            elif t = typeof<Guid []> then r.uuidArray n |> box
            elif t = typeof<Guid [] option> then r.uuidArrayOrNone n |> box
            else
                failwithf $"Could not read column '%s{n}' as %s{t.FullName}"

        fun (reader: RowReader) ->
            let values = [| for (name, ty) in fields do readField reader (name.ToLowerInvariant()) ty |]
            make values

    let optFromNull (t: 't | null) = 
        match t with
            | null -> None
            | _ -> Some t

    let connString: string =
        Sql.host "localhost"
        |> Sql.database "giraffe"
        |> Sql.username "postgres"
        |> Sql.password "postgres"
        |> Sql.port 5432
        |> Sql.formatConnectionString

    type UserContext =
        static member findByName(name: string) : Task<IdentityUser option> =
            task {
                let! result = 
                    connString 
                    |> Sql.connect
                    |> Sql.query """SELECT * FROM "Users" WHERE "NormalizedUserName" = @username"""
                    |> Sql.parameters ["username", Sql.string name]
                    |> Sql.executeAsync autoGeneratedRecordReader<IdentityUser>

                let first = 
                    match result with
                    | [] -> None
                    | _ -> Some (List.head result)

                return first
            }
